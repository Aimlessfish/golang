package bot

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"strings"
	"sync"
	"time"

	"github.com/playwright-community/playwright-go"
)

// Session represents a logged-in bot session with browser automation
type Session struct {
	ID          string
	UserID      string
	Port        int
	server      *http.Server
	mutex       sync.Mutex
	isActive    bool
	ctx         context.Context
	cancel      context.CancelFunc
	allocCtx    context.Context
	allocCancel context.CancelFunc
	IsLoggedIn  bool
	loginChan   chan bool
	CreatedAt   time.Time
	credential  *SteamCredential
	debugPort   int
	profileDir  string
}

// NewSession creates a new bot session
func NewSession(id, userID string, port int) *Session {
	return &Session{
		ID:         id,
		UserID:     userID,
		Port:       port,
		isActive:   false,
		IsLoggedIn: false,
		loginChan:  make(chan bool),
		CreatedAt:  time.Now(),
		credential: nil,
	}
}

// NewSessionWithCredentials creates a new bot session with auto-login
func NewSessionWithCredentials(id, userID string, port int, cred *SteamCredential) *Session {
	return &Session{
		ID:         id,
		UserID:     userID,
		Port:       port,
		isActive:   false,
		IsLoggedIn: false,
		loginChan:  make(chan bool),
		CreatedAt:  time.Now(),
		credential: cred,
	}
}

// Start begins listening on the session's port and launches browser
// This method blocks until the user completes the Steam login
func (s *Session) Start() error {
	s.mutex.Lock()

	if s.isActive {
		s.mutex.Unlock()
		return fmt.Errorf("session %s already active", s.ID)
	}

	// Initialize Playwright and browser
	if err := s.initBrowser(); err != nil {
		s.mutex.Unlock()
		return fmt.Errorf("failed to initialize browser: %w", err)
	}

	// Navigate to Steam login page
	if err := s.navigateToSteamLogin(); err != nil {
		s.mutex.Unlock()
		return fmt.Errorf("failed to navigate to Steam login: %w", err)
	}

	s.mutex.Unlock()

	// If credentials are provided, attempt auto-login
	if s.credential != nil {
		log.Printf("[Session %s] Auto-logging in with account: %s", s.ID, s.credential.AccountName)
		if err := s.performAutoLogin(); err != nil {
			log.Printf("[Session %s] Auto-login failed: %v, waiting for manual login", s.ID, err)
			log.Printf("[Session %s] Please log in manually in the browser window.", s.ID)
		}
	} else {
		log.Printf("[Session %s] Browser opened at Steam login. Waiting for login to complete...", s.ID)
		log.Printf("[Session %s] Please log in manually in the browser window.", s.ID)
	}

	// Start monitoring for login completion
	go s.monitorLogin()

	// Block until login is complete
	<-s.loginChan

	s.mutex.Lock()
	s.IsLoggedIn = true
	s.mutex.Unlock()

	log.Printf("[Session %s] âœ“ Login detected! Starting API server...", s.ID)

	// Now start the HTTP server for automation
	mux := http.NewServeMux()

	// Health check endpoint
	mux.HandleFunc("/health", s.handleHealth)

	// Action trigger endpoints
	mux.HandleFunc("/action/open-profile", s.handleOpenProfile)
	mux.HandleFunc("/action/navigate", s.handleNavigate)
	mux.HandleFunc("/action/get-screenshot", s.handleGetScreenshot)
	mux.HandleFunc("/status", s.handleStatus)

	s.server = &http.Server{
		Addr:    fmt.Sprintf(":%d", s.Port),
		Handler: mux,
	}

	s.mutex.Lock()
	s.isActive = true
	s.mutex.Unlock()

	go func() {
		log.Printf("[Session %s] API server ready on port %d", s.ID, s.Port)
		if err := s.server.ListenAndServe(); err != http.ErrServerClosed {
			log.Printf("[Session %s] Server error: %v", s.ID, err)
		}
	}()

	return nil
}

// Stop shuts down the session server and closes browser
func (s *Session) Stop() error {
	s.mutex.Lock()
	defer s.mutex.Unlock()

	if !s.isActive {
		return nil
	}

	s.isActive = false

	// Close browser resources
	if s.page != nil {
		s.page.Close()
	}
	if s.context != nil {
		s.context.Close()
	}
	if s.browser != nil {
		s.browser.Close()
	}
	if s.pw != nil {
		s.pw.Stop()
	}

	if s.server != nil {
		return s.server.Close()
	}
	return nil
}

// NavigateTo navigates the session browser to a URL
func (s *Session) NavigateTo(url string) error {
	if !s.IsLoggedIn {
		return fmt.Errorf("session not logged in")
	}
	return s.navigateTo(url)
}

// GetScreenshot returns a PNG screenshot of the current page
func (s *Session) GetScreenshot() ([]byte, error) {
	s.mutex.Lock()
	defer s.mutex.Unlock()

	if s.page == nil {
		return nil, fmt.Errorf("browser not initialized")
	}

	return s.page.Screenshot()
}

// GetCurrentURL returns the current URL of the session
func (s *Session) GetCurrentURL() string {
	return s.getCurrentURL()
}

// ClickElement finds and clicks an element by CSS selector
func (s *Session) ClickElement(selector string) error {
	if !s.IsLoggedIn {
		return fmt.Errorf("session not logged in")
	}

	s.mutex.Lock()
	defer s.mutex.Unlock()

	if s.page == nil {
		return fmt.Errorf("browser not initialized")
	}

	element, err := s.page.QuerySelector(selector)
	if err != nil || element == nil {
		return fmt.Errorf("element not found: %s", selector)
	}

	return element.Click()
}

// WaitForSelector waits for an element to appear
func (s *Session) WaitForSelector(selector string, timeoutMs int) error {
	if !s.IsLoggedIn {
		return fmt.Errorf("session not logged in")
	}

	s.mutex.Lock()
	defer s.mutex.Unlock()

	if s.page == nil {
		return fmt.Errorf("browser not initialized")
	}

	_, err := s.page.WaitForSelector(selector, playwright.PageWaitForSelectorOptions{
		Timeout: playwright.Float(float64(timeoutMs)),
	})
	return err
}

// GetPage returns the Playwright page for advanced automation
func (s *Session) GetPage() playwright.Page {
	return s.page
}

// Handler functions

func (s *Session) handleHealth(w http.ResponseWriter, r *http.Request) {
	json.NewEncoder(w).Encode(map[string]interface{}{
		"status":    "ok",
		"sessionId": s.ID,
		"userId":    s.UserID,
		"port":      s.Port,
	})
}

func (s *Session) handleStatus(w http.ResponseWriter, r *http.Request) {
	s.mutex.Lock()
	defer s.mutex.Unlock()

	json.NewEncoder(w).Encode(map[string]interface{}{
		"sessionId":  s.ID,
		"userId":     s.UserID,
		"port":       s.Port,
		"active":     s.isActive,
		"isLoggedIn": s.IsLoggedIn,
		"currentUrl": s.getCurrentURL(),
		"createdAt":  s.CreatedAt,
	})
}

func (s *Session) handleOpenProfile(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	if !s.IsLoggedIn {
		http.Error(w, "Session not logged in yet", http.StatusPreconditionFailed)
		return
	}

	log.Printf("[Session %s] Executing action: open-profile for user %s", s.ID, s.UserID)

	url := fmt.Sprintf("https://steamcommunity.com/id/%s", s.UserID)
	err := s.navigateTo(url)
	if err != nil {
		http.Error(w, fmt.Sprintf("Error: %v", err), http.StatusInternalServerError)
		return
	}

	json.NewEncoder(w).Encode(map[string]interface{}{
		"status":  "success",
		"action":  "open-profile",
		"userId":  s.UserID,
		"message": fmt.Sprintf("Opened profile for %s", s.UserID),
	})
}

func (s *Session) handleNavigate(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	var payload struct {
		URL string `json:"url"`
	}

	if err := json.NewDecoder(r.Body).Decode(&payload); err != nil {
		http.Error(w, "Invalid JSON", http.StatusBadRequest)
		return
	}

	if payload.URL == "" {
		http.Error(w, "URL is required", http.StatusBadRequest)
		return
	}

	log.Printf("[Session %s] Executing action: navigate to %s", s.ID, payload.URL)

	err := s.navigateTo(payload.URL)
	if err != nil {
		http.Error(w, fmt.Sprintf("Error: %v", err), http.StatusInternalServerError)
		return
	}

	json.NewEncoder(w).Encode(map[string]interface{}{
		"status":  "success",
		"action":  "navigate",
		"url":     payload.URL,
		"message": fmt.Sprintf("Navigated to %s", payload.URL),
	})
}

func (s *Session) handleGetScreenshot(w http.ResponseWriter, r *http.Request) {
	s.mutex.Lock()
	defer s.mutex.Unlock()

	if s.page == nil {
		http.Error(w, "Browser not initialized", http.StatusInternalServerError)
		return
	}

	screenshot, err := s.page.Screenshot()
	if err != nil {
		http.Error(w, fmt.Sprintf("Screenshot failed: %v", err), http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "image/png")
	w.Write(screenshot)
}

// Helper methods

func (s *Session) initBrowser() error {
	var err error
	s.pw, err = playwright.Run()
	if err != nil {
		return err
	}

	s.browser, err = s.pw.Chromium.Launch(playwright.BrowserTypeLaunchOptions{
		Headless: playwright.Bool(false), // Visible browser for manual login
		Args: []string{
			"--disable-blink-features=AutomationControlled",
		},
	})
	if err != nil {
		return err
	}

	s.context, err = s.browser.NewContext(playwright.BrowserNewContextOptions{
		UserAgent: playwright.String("Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"),
	})
	if err != nil {
		return err
	}

	s.page, err = s.context.NewPage()
	if err != nil {
		return err
	}

	return nil
}

func (s *Session) navigateToSteamLogin() error {
	if s.page == nil {
		return fmt.Errorf("browser not initialized")
	}

	// Choose login page based on credential login method
	loginURL := "https://store.steampowered.com/login/"
	if s.credential != nil && s.credential.LoginMethod == LoginMethodQR {
		loginURL = "https://steamcommunity.com/login/home/?goto="
		log.Printf("[Session %s] Navigating to Steam QR login page", s.ID)
	} else {
		log.Printf("[Session %s] Navigating to Steam login page", s.ID)
	}

	_, err := s.page.Goto(loginURL)
	return err
}

func (s *Session) navigateTo(url string) error {
	if s.page == nil {
		return fmt.Errorf("browser not initialized")
	}

	_, err := s.page.Goto(url)
	return err
}

func (s *Session) getCurrentURL() string {
	if s.page == nil {
		return ""
	}
	return s.page.URL()
}

// monitorLogin continuously checks if the user has successfully logged into Steam
func (s *Session) monitorLogin() {
	for {
		if s.page == nil {
			return
		}

		currentURL := s.page.URL()

		// Check if we've successfully navigated away from login page
		// Steam redirects to store or community after successful login
		if currentURL != "" &&
			!contains(currentURL, "store.steampowered.com/login") &&
			!contains(currentURL, "login.steampowered.com") &&
			!contains(currentURL, "help.steampowered.com/wizard/Login") {

			// Additional check: look for Steam-specific logged-in elements
			if s.detectLoggedInState() {
				log.Printf("[Session %s] Login successful! Redirected to: %s", s.ID, currentURL)
				s.loginChan <- true
				return
			}
		}

		// Check every 500ms
		time.Sleep(500 * time.Millisecond)
	}
}

// detectLoggedInState checks if we're actually logged in by looking for Steam UI elements
func (s *Session) detectLoggedInState() bool {
	if s.page == nil {
		return false
	}

	// Check for common logged-in indicators
	// Steam shows user account name when logged in
	account, err := s.page.QuerySelector("#account_pulldown, .account_menu, [class*='accountmenu']")
	if err == nil && account != nil {
		return true
	}

	// Check if we're on a Steam page that requires login
	currentURL := s.page.URL()
	if contains(currentURL, "steamcommunity.com") ||
		(contains(currentURL, "store.steampowered.com") && !contains(currentURL, "/login")) {
		return true
	}

	return false
}

func contains(s, substr string) bool {
	return strings.Contains(s, substr)
}

// performAutoLogin attempts to automatically log in using stored credentials
func (s *Session) performAutoLogin() error {
	if s.page == nil {
		return fmt.Errorf("browser not initialized")
	}

	if s.credential == nil {
		return fmt.Errorf("no credentials provided")
	}

	// Handle QR code login differently
	if s.credential.LoginMethod == LoginMethodQR {
		return s.performQRLogin()
	}

	// Standard username/password login
	return s.performPasswordLogin()
}

// performPasswordLogin handles username + password authentication
func (s *Session) performPasswordLogin() error {
	// Wait for login form to load
	time.Sleep(2 * time.Second)

	// Fill in username
	usernameInput, err := s.page.QuerySelector("input[type='text'], input[name='username']")
	if err != nil || usernameInput == nil {
		return fmt.Errorf("could not find username input field")
	}

	if err := usernameInput.Fill(s.credential.AccountName); err != nil {
		return fmt.Errorf("failed to fill username: %w", err)
	}

	// Fill in password
	passwordInput, err := s.page.QuerySelector("input[type='password'], input[name='password']")
	if err != nil || passwordInput == nil {
		return fmt.Errorf("could not find password input field")
	}

	if err := passwordInput.Fill(s.credential.Password); err != nil {
		return fmt.Errorf("failed to fill password: %w", err)
	}

	// Click sign in button
	signInButton, err := s.page.QuerySelector("button[type='submit'], button.login_btn")
	if err != nil || signInButton == nil {
		return fmt.Errorf("could not find sign in button")
	}

	if err := signInButton.Click(); err != nil {
		return fmt.Errorf("failed to click sign in button: %w", err)
	}

	log.Printf("[Session %s] Credentials entered, checking for 2FA...", s.ID)

	// Wait a bit for potential 2FA prompt
	time.Sleep(3 * time.Second)

	// Check if 2FA is required
	if s.credential.SharedSecret != "" {
		// Try to handle Steam Guard 2FA
		if err := s.handleSteamGuard2FA(); err != nil {
			log.Printf("[Session %s] 2FA handling failed: %v", s.ID, err)
			return err
		}
	} else {
		log.Printf("[Session %s] No 2FA credentials available, may need manual input", s.ID)
	}

	return nil
}

// performQRLogin handles QR code based authentication
func (s *Session) performQRLogin() error {
	log.Printf("[Session %s] QR code login - waiting for user to scan QR code...", s.ID)
	log.Printf("[Session %s] Please scan the QR code with your Steam Mobile app", s.ID)

	// QR login is handled by user scanning the code
	// The browser will automatically redirect on successful scan
	// No automation needed - just wait for login completion

	return nil
}

// handleSteamGuard2FA handles Steam Guard 2FA authentication
func (s *Session) handleSteamGuard2FA() error {
	if s.page == nil || s.credential == nil {
		return fmt.Errorf("browser or credentials not initialized")
	}

	// Check if 2FA input is present
	twoFAInput, err := s.page.QuerySelector("input[type='text'][class*='authcode'], input[id*='authcode']")
	if err != nil || twoFAInput == nil {
		// No 2FA prompt, might have auto-accepted or not needed
		return nil
	}

	log.Printf("[Session %s] 2FA required, generating code...", s.ID)

	// Generate TOTP code from shared secret
	code, err := generateSteamGuardCode(s.credential.SharedSecret)
	if err != nil {
		return fmt.Errorf("failed to generate 2FA code: %w", err)
	}

	// Enter 2FA code
	if err := twoFAInput.Fill(code); err != nil {
		return fmt.Errorf("failed to fill 2FA code: %w", err)
	}

	// Submit 2FA
	submitButton, err := s.page.QuerySelector("button[type='submit']")
	if err == nil && submitButton != nil {
		submitButton.Click()
	}

	log.Printf("[Session %s] 2FA code submitted", s.ID)

	return nil
}

// generateSteamGuardCode generates a Steam Guard TOTP code
// This is a placeholder - you'll need to implement actual Steam Guard TOTP generation
func generateSteamGuardCode(sharedSecret string) (string, error) {
	// TODO: Implement Steam Guard TOTP generation
	// Steam uses a modified base32 alphabet and specific time-based algorithm
	// For now, return error to indicate manual 2FA needed
	return "", fmt.Errorf("Steam Guard TOTP generation not yet implemented - please enter code manually")
}
